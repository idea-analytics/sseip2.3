# duckdb_spatial_join_functions.R
# ------------------------------------------------------------
# A lightweight wrapper that mimics sf::st_join() but executes
# the spatial predicate inside DuckDB/MotherDuck using the
# `spatial` extension.  It works with remote tables generated by
# dbplyr / dplyr (`tbl()` objects) and keeps the join push‑down
# in SQL so the heavy lifting happens in‑database.
# ------------------------------------------------------------

# ------------------------------------------------------------
# Predicate mapping (keep this at top‑level so all helpers see it)
# ------------------------------------------------------------
duckdb_spatial_predicates <- list(
  st_intersects        = "ST_Intersects",
  st_within            = "ST_Within",
  st_contains          = "ST_Contains",
  st_contains_properly = "ST_ContainsProperly",
  st_covers            = "ST_Covers",
  st_covered_by        = "ST_CoveredBy",
  st_crosses           = "ST_Crosses",
  st_overlaps          = "ST_Overlaps",
  st_equals            = "ST_Equals",
  st_touches           = "ST_Touches",
  st_disjoint          = "ST_Disjoint",
  st_dwithin           = "ST_DWithin"
)

#' md_spatial_join()
#'
#' Perform a spatial join between two DuckDB remote tables
#' using any predicate supported by the DuckDB *spatial* extension.
#'
#' @param x,y   dbplyr `tbl_sql` objects (left / right tables).
#' @param join  Character string naming an OGC predicate in
#'              `duckdb_spatial_predicates` (default: "st_intersects").
#' @param how   "inner" (default) or "left".
#' @param x_geom,y_geom  Geometry column names in `x` / `y`.
#' @param distance  Distance (numeric) for `st_dwithin` predicate.
#' @param suffix  Passed to dplyr join helpers.
#' @param ...   Extra args passed to dplyr join (e.g., copy = TRUE).
#'
#' @return A dbplyr `tbl_sql` representing the joined result.
#' @export
#' @examples
#' joined <- md_spatial_join(pts, polys)                       # intersects
#' near   <- md_spatial_join(pts, schools, join = "st_dwithin",
#'                              distance = 250, how = "left")
#'
md_spatial_join <- function(x, y,
                            join     = "st_intersects",
                            how      = c("inner", "left"),
                            x_geom   = "geometry",
                            y_geom   = "geometry",
                            distance = NULL,
                            suffix   = c(".x", ".y"),
                            ...) {
  stopifnot(inherits(x, "tbl_sql"), inherits(y, "tbl_sql"))

  how  <- match.arg(how)
  join <- tolower(join)

  if (!join %in% names(duckdb_spatial_predicates)) {
    stop("Unsupported join predicate: ", join)
  }

  fn_sql <- duckdb_spatial_predicates[[join]]

  # Quote identifiers to avoid name collisions / SQL injection

  lhs <- paste0("LHS.", x_geom)
  rhs <- paste0("RHS.", y_geom)
  #
  #lhs <- DBI::dbQuoteIdentifier(DBI::ANSI(), paste0("LHS.", x_geom))
  #rhs <- DBI::dbQuoteIdentifier(DBI::ANSI(), paste0("RHS.", y_geom))



  pred <- if (fn_sql == "ST_DWithin") {
    if (is.null(distance)) {
      stop("`distance` must be supplied for st_dwithin joins.")
    }
    sprintf("%s(%s, %s, %s)", fn_sql, lhs, rhs,
            format(distance, scientific = FALSE))
  } else {
    sprintf("%s(%s, %s)", fn_sql, lhs, rhs)
  }

  join_fun <- switch(how,
                     inner = dplyr::inner_join,
                     left  = dplyr::left_join)

  join_fun(x, y,
           sql_on = dplyr::sql(pred),
           suffix = suffix,
           ...)
}

# ------------------------------------------------------------
# Autogenerate convenience wrappers: duck_join_intersects(), etc.
# ------------------------------------------------------------

.make_duck_join <- function(alias, predicate) {
  force(alias); force(predicate)
  wrapper <- function(x, y, how = "inner", x_geom = "geometry", y_geom = "geometry", ...) {
    md_spatial_join(x, y, join = predicate, how = how,
                    x_geom = x_geom, y_geom = y_geom, ...)
  }
  # export into parent namespace when sourced
  assign(alias, wrapper, envir = parent.env(environment()))
  invisible(alias)
}


# ------------------------------------------------------------
# 4. duck_collect_sf(): bring a remote table into R as sf
# ------------------------------------------------------------
#' duck_collect_sf
#' @description
#' Collect a DuckDB remote table, converting *all* geometry‑typed
#' columns to WKT on the server via `ST_AsText()`. Then, choose
#' one geometry column (default "geometry") to become the active
#' `sf` geometry. Its companion CRS column is expected to be
#' named `crs_duckspatial` plus the same suffix (e.g.,
#' `geometry.x` → `crs_duckspatial.x`). Both selected columns are
#' renamed to `geometry` and `crs_duckspatial` in the output for
#' consistency.
#'
#' @param tbl  A dbplyr `tbl_sql` object.
#' @param geometry_col  Which geometry column to promote to sf.
#'        If NULL the function will pick "geometry" if present; if
#'        only one candidate exists it will use that; otherwise it
#'        errors and asks you to specify.
#' @param keep_wkt  Keep the WKT column after conversion? Default
#'        FALSE (column dropped).
#' @return An `sf` data frame.
#' @export
md_collect_sf <- function(.tbl, geometry_col = NULL, keep_wkt = FALSE) {
  stopifnot(inherits(.tbl, "tbl_sql"))

  cols <- colnames(.tbl)
  geom_cols <- cols[grepl("^geometry", cols, ignore.case = TRUE)]
  if (length(geom_cols) == 0) {
    stop("No geometry‑like columns found (names starting with 'geometry').")
  }

  # Choose the geometry column to convert to sf geometry
  if (is.null(geometry_col)) {
    if ("geometry" %in% geom_cols) {
      geometry_col <- "geometry"
    } else if (length(geom_cols) == 1) {
      geometry_col <- geom_cols[1]
    } else {
      stop("Multiple geometry columns found (",
           paste(geom_cols, collapse = ", "),
           "); specify one via `geometry_col`.")
    }
  }
  if (!geometry_col %in% geom_cols) {
    stop("`geometry_col` (", geometry_col, ") not found in table.")
  }

  # Build query: convert *all* geometry columns to WKT
  tbl_wkt <- .tbl
  for (g in geom_cols) {
    tbl_wkt <- tbl_wkt %>%
      dplyr::mutate(!!g := dplyr::sql(sprintf('ST_AsText("%s")', g)))
  }
  #tbl_wkt <- .tbl %>% mutate(across(starts_with("geometry"), ~dplyr::sql(sprintf("ST_AsText(\'%s\')", .x))))

  df <- dplyr::collect(tbl_wkt)

  # Identify companion CRS column (same suffix) or fallback
  suffix <- sub("^geometry", "", geometry_col)  # e.g., ".x" or ""
  crs_col_candidate <- paste0("crs_duckspatial", suffix)
  crs_col <- if (crs_col_candidate %in% names(df)) {
    crs_col_candidate
  } else if ("crs_duckspatial" %in% names(df)) {
    "crs_duckspatial"
  } else {
    NA_character_
  }
  crs_val <- if (!is.na(crs_col)) unique(df[[crs_col]])[1] else NA

  # Rename selected geometry + crs columns to canonical names
  df <- dplyr::rename(df, geometry = !!rlang::sym(geometry_col))
  if (!is.na(crs_col)) {
    df <- dplyr::rename(df, crs_duckspatial = !!rlang::sym(crs_col))
  }

  # Convert to sf
  sf_obj <- sf::st_as_sf(df,
                         wkt    = "geometry",
                         crs    = crs_val,
                         remove = !keep_wkt)
  return(sf_obj)
}





for (pred in names(duckdb_spatial_predicates)) {
  alias <- sub("^st_", "md_join_", pred)
  .make_duck_join(alias, pred)
}

# Uncomment to list available helpers after sourcing
# cat("Created helpers:", paste(ls(pattern = "^md_join_"), collapse = ", "), "\n")
